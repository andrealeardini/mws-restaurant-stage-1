{"version":3,"sources":["idb.js","dbHelper.js","main.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main_all.js","sourcesContent":["'use strict';\n\n(function () {\n  function toArray(arr) {\n    return Array.prototype.slice.call(arr);\n  }\n\n  function promisifyRequest(request) {\n    return new Promise(function (resolve, reject) {\n      request.onsuccess = function () {\n        resolve(request.result);\n      };\n\n      request.onerror = function () {\n        reject(request.error);\n      };\n    });\n  }\n\n  function promisifyRequestCall(obj, method, args) {\n    var request;\n    var p = new Promise(function (resolve, reject) {\n      request = obj[method].apply(obj, args);\n      promisifyRequest(request).then(resolve, reject);\n    });\n\n    p.request = request;\n    return p;\n  }\n\n  function promisifyCursorRequestCall(obj, method, args) {\n    var p = promisifyRequestCall(obj, method, args);\n    return p.then(function (value) {\n      if (!value) return;\n      return new Cursor(value, p.request);\n    });\n  }\n\n  function proxyProperties(ProxyClass, targetProp, properties) {\n    properties.forEach(function (prop) {\n      Object.defineProperty(ProxyClass.prototype, prop, {\n        get: function () {\n          return this[targetProp][prop];\n        },\n        set: function (val) {\n          this[targetProp][prop] = val;\n        }\n      });\n    });\n  }\n\n  function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function (prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function () {\n        return promisifyRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function proxyMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function (prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function () {\n        return this[targetProp][prop].apply(this[targetProp], arguments);\n      };\n    });\n  }\n\n  function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {\n    properties.forEach(function (prop) {\n      if (!(prop in Constructor.prototype)) return;\n      ProxyClass.prototype[prop] = function () {\n        return promisifyCursorRequestCall(this[targetProp], prop, arguments);\n      };\n    });\n  }\n\n  function Index(index) {\n    this._index = index;\n  }\n\n  proxyProperties(Index, '_index', [\n    'name',\n    'keyPath',\n    'multiEntry',\n    'unique'\n  ]);\n\n  proxyRequestMethods(Index, '_index', IDBIndex, [\n    'get',\n    'getKey',\n    'getAll',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(Index, '_index', IDBIndex, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  function Cursor(cursor, request) {\n    this._cursor = cursor;\n    this._request = request;\n  }\n\n  proxyProperties(Cursor, '_cursor', [\n    'direction',\n    'key',\n    'primaryKey',\n    'value'\n  ]);\n\n  proxyRequestMethods(Cursor, '_cursor', IDBCursor, [\n    'update',\n    'delete'\n  ]);\n\n  // proxy 'next' methods\n  ['advance', 'continue', 'continuePrimaryKey'].forEach(function (methodName) {\n    if (!(methodName in IDBCursor.prototype)) return;\n    Cursor.prototype[methodName] = function () {\n      var cursor = this;\n      var args = arguments;\n      return Promise.resolve().then(function () {\n        cursor._cursor[methodName].apply(cursor._cursor, args);\n        return promisifyRequest(cursor._request).then(function (value) {\n          if (!value) return;\n          return new Cursor(value, cursor._request);\n        });\n      });\n    };\n  });\n\n  function ObjectStore(store) {\n    this._store = store;\n  }\n\n  ObjectStore.prototype.createIndex = function () {\n    return new Index(this._store.createIndex.apply(this._store, arguments));\n  };\n\n  ObjectStore.prototype.index = function () {\n    return new Index(this._store.index.apply(this._store, arguments));\n  };\n\n  proxyProperties(ObjectStore, '_store', [\n    'name',\n    'keyPath',\n    'indexNames',\n    'autoIncrement'\n  ]);\n\n  proxyRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'put',\n    'add',\n    'delete',\n    'clear',\n    'get',\n    'getAll',\n    'getKey',\n    'getAllKeys',\n    'count'\n  ]);\n\n  proxyCursorRequestMethods(ObjectStore, '_store', IDBObjectStore, [\n    'openCursor',\n    'openKeyCursor'\n  ]);\n\n  proxyMethods(ObjectStore, '_store', IDBObjectStore, [\n    'deleteIndex'\n  ]);\n\n  function Transaction(idbTransaction) {\n    this._tx = idbTransaction;\n    this.complete = new Promise(function (resolve, reject) {\n      idbTransaction.oncomplete = function () {\n        resolve();\n      };\n      idbTransaction.onerror = function () {\n        reject(idbTransaction.error);\n      };\n      idbTransaction.onabort = function () {\n        reject(idbTransaction.error);\n      };\n    });\n  }\n\n  Transaction.prototype.objectStore = function () {\n    return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));\n  };\n\n  proxyProperties(Transaction, '_tx', [\n    'objectStoreNames',\n    'mode'\n  ]);\n\n  proxyMethods(Transaction, '_tx', IDBTransaction, [\n    'abort'\n  ]);\n\n  function UpgradeDB(db, oldVersion, transaction) {\n    this._db = db;\n    this.oldVersion = oldVersion;\n    this.transaction = new Transaction(transaction);\n  }\n\n  UpgradeDB.prototype.createObjectStore = function () {\n    return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));\n  };\n\n  proxyProperties(UpgradeDB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(UpgradeDB, '_db', IDBDatabase, [\n    'deleteObjectStore',\n    'close'\n  ]);\n\n  function DB(db) {\n    this._db = db;\n  }\n\n  DB.prototype.transaction = function () {\n    return new Transaction(this._db.transaction.apply(this._db, arguments));\n  };\n\n  proxyProperties(DB, '_db', [\n    'name',\n    'version',\n    'objectStoreNames'\n  ]);\n\n  proxyMethods(DB, '_db', IDBDatabase, [\n    'close'\n  ]);\n\n  // Add cursor iterators\n  // TODO: remove this once browsers do the right thing with promises\n  ['openCursor', 'openKeyCursor'].forEach(function (funcName) {\n    [ObjectStore, Index].forEach(function (Constructor) {\n      Constructor.prototype[funcName.replace('open', 'iterate')] = function () {\n        var args = toArray(arguments);\n        var callback = args[args.length - 1];\n        var nativeObject = this._store || this._index;\n        var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));\n        request.onsuccess = function () {\n          callback(request.result);\n        };\n      };\n    });\n  });\n\n  // polyfill getAll\n  [Index, ObjectStore].forEach(function (Constructor) {\n    if (Constructor.prototype.getAll) return;\n    Constructor.prototype.getAll = function (query, count) {\n      var instance = this;\n      var items = [];\n\n      return new Promise(function (resolve) {\n        instance.iterateCursor(query, function (cursor) {\n          if (!cursor) {\n            resolve(items);\n            return;\n          }\n          items.push(cursor.value);\n\n          if (count !== undefined && items.length == count) {\n            resolve(items);\n            return;\n          }\n          cursor.continue();\n        });\n      });\n    };\n  });\n\n  var exp = {\n    open: function (name, version, upgradeCallback) {\n      var p = promisifyRequestCall(indexedDB, 'open', [name, version]);\n      var request = p.request;\n\n      request.onupgradeneeded = function (event) {\n        if (upgradeCallback) {\n          upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));\n        }\n      };\n\n      return p.then(function (db) {\n        return new DB(db);\n      });\n    },\n    delete: function (name) {\n      return promisifyRequestCall(indexedDB, 'deleteDatabase', [name]);\n    }\n  };\n\n  if (typeof module !== 'undefined') {\n    module.exports = exp;\n    module.exports.default = module.exports;\n  } else {\n    self.idb = exp;\n  }\n}());","/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n    set dbPromise(value) {\r\n        this._dbPromise = value;\r\n    }\r\n\r\n    get dbPromise() {\r\n        return this._dbPromise;\r\n    }\r\n\r\n    set dbOpened(value) {\r\n        this._dbOpened = value;\r\n    }\r\n\r\n    get dbOpened() {\r\n        return this._dbOpened;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Database URL.\r\n     * Change this to restaurants.json file location on your server.\r\n     */\r\n    static get DATABASE_URL() {\r\n        const port = 1337 // Change this to your server port\r\n        return `http://localhost:${port}/restaurants`;\r\n    }\r\n\r\n    static get DATABASE_REVIEWS_URL() {\r\n        const port = 1337 // Change this to your server port\r\n        return `http://localhost:${port}/reviews`;\r\n    }\r\n\r\n    /**\r\n     * Fetch all restaurants.\r\n     */\r\n    static fetchRestaurants(callback) {\r\n\r\n        // open DB and set dbPromise\r\n        return DBHelper.openDB().then(function (db) {\r\n            if (db) {\r\n                DBHelper.dbPromise = db;\r\n                // console.log(DBHelper.dbPromise);\r\n                // Read restaurants from DB;\r\n                return DBHelper.getRestaurantsFromDB().then(restaurants => {\r\n                    if (restaurants.length) {\r\n                        return callback(null, restaurants);\r\n                    } else {\r\n                        // console.log('No restaurants in db');\r\n                        DBHelper.fetchRestaurantsFromNetwork(callback);\r\n                    }\r\n                });\r\n            } else {\r\n                // console.log('db not found');\r\n                DBHelper.fetchRestaurantsFromNetwork(callback);\r\n            }\r\n        }).then(function () {}).catch(function () {\r\n            // console.log('Catch the promise error');\r\n            DBHelper.fetchRestaurantsFromNetwork(callback);\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Fetch all restaurants from network.\r\n     */\r\n    static fetchRestaurantsFromNetwork(callback, saveToDB = true) {\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open('GET', DBHelper.DATABASE_URL);\r\n        xhr.onload = () => {\r\n            if (xhr.status === 200) { // Got a success response from server!\r\n                const restaurants = JSON.parse(xhr.responseText);\r\n                // console.log('Ristoranti letti dal server');\r\n                callback(null, restaurants);\r\n                // write restaurants to db\r\n                if (saveToDB) {\r\n                    DBHelper.saveRestaurantsToDB(restaurants);\r\n                }\r\n            } else { // Oops!. Got an error from server.\r\n                const error = (`Request failed. Returned status of ${xhr.status}`);\r\n                callback(error, null);\r\n            }\r\n        };\r\n        xhr.send();\r\n    }\r\n\r\n\r\n    /**\r\n     * Fetch a restaurant by its ID.\r\n     */\r\n    static fetchRestaurantById(id, callback) {\r\n        // fetch all restaurants with proper error handling.\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                const restaurant = restaurants.find(r => r.id == id);\r\n                if (restaurant) { // Got the restaurant\r\n                    callback(null, restaurant);\r\n                } else { // Restaurant does not exist in the database\r\n                    callback('Restaurant does not exist', null);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a cuisine type with proper error handling.\r\n     */\r\n    static fetchRestaurantByCuisine(cuisine, callback) {\r\n        // Fetch all restaurants  with proper error handling\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Filter restaurants to have only given cuisine type\r\n                const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n                callback(null, results);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a neighborhood with proper error handling.\r\n     */\r\n    static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Filter restaurants to have only given neighborhood\r\n                const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n                callback(null, results);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n     */\r\n    static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                let results = restaurants\r\n                if (cuisine != 'all') { // filter by cuisine\r\n                    results = results.filter(r => r.cuisine_type == cuisine);\r\n                }\r\n                if (neighborhood != 'all') { // filter by neighborhood\r\n                    results = results.filter(r => r.neighborhood == neighborhood);\r\n                }\r\n                callback(null, results);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch all neighborhoods with proper error handling.\r\n     */\r\n    static fetchNeighborhoods(callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Get all neighborhoods from all restaurants\r\n                const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n                // Remove duplicates from neighborhoods\r\n                const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n                callback(null, uniqueNeighborhoods);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch all cuisines with proper error handling.\r\n     */\r\n    static fetchCuisines(callback) {\r\n        // Fetch all restaurants\r\n        DBHelper.fetchRestaurants((error, restaurants) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                // Get all cuisines from all restaurants\r\n                const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n                // Remove duplicates from cuisines\r\n                const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n                callback(null, uniqueCuisines);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Restaurant page URL.\r\n     */\r\n    static urlForRestaurant(restaurant) {\r\n        return (`./restaurant.html?id=${restaurant.id}`);\r\n    }\r\n\r\n    /**\r\n     * Restaurant image URL.\r\n     */\r\n    static imageUrlForRestaurant(restaurant) {\r\n        // use id instead photograph to avoid an error with Casa Enrique (a bug?)\r\n        return (`/img/${restaurant.id}`);\r\n    }\r\n\r\n    /**\r\n     * Restaurant image description.\r\n     */\r\n    static imageDescriptionForRestaurant(restaurant) {\r\n        // Please note that I used Google Translate. Translations can be a little fun... \r\n        const altImg = [\r\n            \"Inside view of the Mission Chinese Food restaurant. Many people talk to each other\",\r\n            \"A pizza cut into six slices\",\r\n            \"Inside view of Kang Ho Dong Baekjeong restaurant. You can see various modern style tables and chairs\",\r\n            \"Panoramic photo of the entrance. You can see the two streets on which the restaurant overlooks\",\r\n            \"Inside view of the Roberto's Pizza. In the background, see the kitchen and some pizza makers\",\r\n            \"Inside view of the Hometown BBQ restaurant. On the wall a huge US flag\",\r\n            \"Two people walking around the restaurand. You can see some customers inside\",\r\n            \"Detail of the The Dutch banner\",\r\n            \"Inside view of the Mu Ramen restaurant. Some customers eat using the typical oriental chopsticks\",\r\n            \"Inside view of restaurant. You see the counter with the window and several bottles.\"\r\n        ];\r\n        return (altImg[restaurant.id - 1]);\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Map marker for a restaurant.\r\n     */\r\n    static mapMarkerForRestaurant(restaurant, map) {\r\n        const marker = new google.maps.Marker({\r\n            position: restaurant.latlng,\r\n            title: restaurant.name,\r\n            url: DBHelper.urlForRestaurant(restaurant),\r\n            map: map,\r\n            animation: google.maps.Animation.DROP\r\n        });\r\n        return marker;\r\n    }\r\n\r\n    static openDB() {\r\n        //check for support\r\n        DBHelper.dbOpened = true;\r\n        if (!('indexedDB' in window)) {\r\n            // console.log('This browser doesn\\'t support IndexedDB');\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return idb.open('restaurants-reviews', 2, upgradeDb => {\r\n            switch (upgradeDb.oldVersion) {\r\n                case 0:\r\n                    upgradeDb.createObjectStore('restaurants', {\r\n                        keyPath: 'id'\r\n                    });\r\n                case 1:\r\n                    // do something\r\n                    upgradeDb.createObjectStore('reviews', {\r\n                        keyPath: 'id'\r\n                    });\r\n                    var reviewsStore = upgradeDb.transaction.objectStore('reviews');\r\n                    reviewsStore.createIndex('restaurant', 'restaurant_id');\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    static addRestaurantToDB(db, data) {\r\n        if (!db) return;\r\n        // console.log('Adding record');\r\n        const tx = db.transaction('restaurants', 'readwrite');\r\n        const restaurantsStore = tx.objectStore('restaurants');\r\n        restaurantsStore.put(data);\r\n        // console.log(\"Record added\");\r\n        return tx.complete;\r\n    }\r\n\r\n    static getRestaurantsFromDB() {\r\n        if (!DBHelper.dbPromise) return;\r\n        const tx = DBHelper.dbPromise.transaction('restaurants', 'readonly');\r\n        const restaurantsStore = tx.objectStore('restaurants');\r\n        return restaurantsStore.getAll();\r\n    }\r\n\r\n\r\n    /*\r\n     * Save data to local database\r\n     */\r\n    static saveRestaurantsToDB(data) {\r\n        if (!(DBHelper.dbOpened)) {\r\n            return\r\n        }\r\n\r\n        let tx = DBHelper.dbPromise.transaction('restaurants', 'readwrite');\r\n        let restaurantsStore = tx.objectStore('restaurants');\r\n        data.forEach(function (restaurant) {\r\n            restaurantsStore.put(restaurant);\r\n        });\r\n        // console.log(\"Local DB Updated from Network\");\r\n        return tx.complete;\r\n    }\r\n\r\n    /*\r\n     * Update favorite to local database\r\n     */\r\n    static updateRestaurantLocalDB(restaurant) {\r\n        if (!(DBHelper.dbOpened)) {\r\n            return\r\n        }\r\n        let tx = DBHelper.dbPromise.transaction('restaurants', 'readwrite');\r\n        let restaurantsStore = tx.objectStore('restaurants');\r\n        restaurantsStore.put(restaurant);\r\n        return tx.complete;\r\n    }\r\n\r\n    /*\r\n     * add restaurant to offline db (will be synch when online)\r\n     */\r\n    static addRestaurantToOfflineDB(restaurant) {\r\n        if (!(DBHelper.dbOpened)) {\r\n            return\r\n        }\r\n        let tx = DBHelper.dbPromise.transaction('offline-restaurants', 'readwrite');\r\n        let restaurantsStore = tx.objectStore('offline-restaurants');\r\n        restaurantsStore.put(restaurant);\r\n        return tx.complete;\r\n    }\r\n\r\n    /**\r\n     * Update the favorite status of the restaurant\r\n     */\r\n    static updateFavorite(id, value, callback) {\r\n        return fetch(`http://localhost:1337/restaurants/${id}/?is_favorite=${value}`, {\r\n            method: \"PUT\",\r\n        }).then(function () {\r\n            // console.log(`Send PUT with favorite=${value}`);\r\n            return DBHelper.fetchRestaurantById(id, (error, restaurant) => {\r\n                self.restaurant = restaurant;\r\n                if (!restaurant) {\r\n                    console.error(error);\r\n                    callback(error, null);\r\n                }\r\n                // console.log(restaurant)\r\n                restaurant.is_favorite = value;\r\n                return DBHelper.updateRestaurantLocalDB(restaurant).then(function () {\r\n                    callback(null, true)\r\n                });\r\n            });\r\n        }).catch(function (error) {\r\n            // console.log(\"Error when try to fetch data on server... \", error)\r\n            // save data offline\r\n            return DBHelper.fetchRestaurantById(id, (error, restaurant) => {\r\n                self.restaurant = restaurant;\r\n                if (!restaurant) {\r\n                    console.error(error);\r\n                    callback(error, null);\r\n                }\r\n                // console.log(restaurant)\r\n                restaurant.is_favorite = value;\r\n                // update the date\r\n                restaurant.updatedAt = new Date();\r\n                return DBHelper.updateRestaurantLocalDB(restaurant).then(function () {\r\n                    // console.log(\"Restaurant saved on the local DB\")\r\n                    callback(null, true);\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delete restaurant from offline-restaurants db.\r\n     */\r\n    static deleteRestaurantFromOffline(restaurant) {\r\n        const tx = DBHelper.dbPromise.transaction('offline-restaurants', 'readwrite');\r\n        const restaurantsStore = tx.objectStore('offline-restaurants');\r\n        return restaurantsStore.delete(restaurant.id);\r\n    };\r\n\r\n    /**\r\n     * Sync all changed to the restaurants \r\n     */\r\n    static syncRestaurants() {\r\n        let restaurantsFromServer = [];\r\n        let restaurantsFromLocalDB = [];\r\n\r\n        return DBHelper.openDB().then(function (db) {\r\n            if (db) {\r\n                DBHelper.dbPromise = db;\r\n                // console.log(DBHelper.dbPromise);\r\n                DBHelper.getRestaurantsFromDB().then(restaurants => {\r\n                    if (restaurants.length) {\r\n                        restaurantsFromLocalDB = restaurants;\r\n                    } else {\r\n                        // console.log('No restaurants in local DB')\r\n                        return\r\n                    }\r\n                }).then(function () {\r\n                    // console.log(\"Restaurants from local DB: \", restaurantsFromLocalDB);\r\n                    return DBHelper.fetchRestaurantsFromNetwork((error, restaurants) => {\r\n                        if (error) {\r\n                            return error;\r\n                        }\r\n                        if (restaurants.length) {\r\n                            restaurantsFromServer = restaurants;\r\n                            // console.log(\"Restaurants from server: \", restaurantsFromServer);\r\n                            // \r\n                            restaurantsFromServer.forEach(function (restaurantFromServer) {\r\n                                const restaurantFromLocalDB = restaurantsFromLocalDB.find(r => r.id == restaurantFromServer.id);\r\n                                if (restaurantFromLocalDB) { // Got the restaurant\r\n                                    const server_updatedAt = new Date(restaurantFromServer.updatedAt);\r\n                                    const localDB_updatedAt = new Date(restaurantFromLocalDB.updatedAt);\r\n                                    // ignore the record with the same date\r\n                                    if (server_updatedAt > localDB_updatedAt) {\r\n                                        DBHelper.updateRestaurantLocalDB(restaurantFromServer);\r\n                                        // console.log('Update local DB:', restaurantFromServer);\r\n                                        DBHelper.setFavoriteStatus(restaurantFromServer);\r\n                                    }\r\n                                    if (server_updatedAt < localDB_updatedAt) {\r\n                                        DBHelper.saveFavoriteToNetwork(restaurantFromLocalDB);\r\n                                        // console.log('Update network DB:', restaurantFromLocalDB)\r\n                                        DBHelper.setFavoriteStatus(restaurantFromLocalDB);\r\n                                    }\r\n                                } else { // Restaurant does not exist in the database\r\n                                    // console.log('Restaurant does not exist');\r\n                                }\r\n\r\n                            })\r\n                        }\r\n                    }, false);\r\n                }).catch(function (error) {\r\n                    // console.log(\"Error in sync\");\r\n                });\r\n            }\r\n        })\r\n    }\r\n\r\n    /*\r\n     * Set favorite status\r\n     */\r\n    static setFavoriteStatus(restaurant) {\r\n        if (restaurant.is_favorite) {\r\n            const favorite = document.getElementById(restaurant.id)\r\n            if ((restaurant.is_favorite == true) || (restaurant.is_favorite == \"true\")) {\r\n                favorite.classList.add('restaurant-name_isfavorite');\r\n            } else {\r\n                favorite.classList.remove('restaurant-name_isfavorite');\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /*\r\n     * Save favorite to network\r\n     */\r\n    static saveFavoriteToNetwork(restaurant) {\r\n        return DBHelper.updateFavorite(restaurant.id, restaurant.is_favorite, (error, updated) => {\r\n            if (updated) {\r\n                // console.log(\"Favorite Updated from LocalDB\");\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Fetch all reviews.\r\n     * @restaurant_id : if specified fetch only the reviews of this restaurants\r\n     */\r\n    static fetchReviews(restaurant_id, callback) {\r\n\r\n        // open DB and set dbPromise\r\n        return DBHelper.openDB().then(function (db) {\r\n            if (db) {\r\n                DBHelper.dbPromise = db;\r\n                // console.log(DBHelper.dbPromise);\r\n                // Read reviews from DB;\r\n                return DBHelper.getReviewsFromDB(restaurant_id).then(reviews => {\r\n                    if (reviews.length) {\r\n                        return callback(null, reviews);\r\n                    } else {\r\n                        // console.log('No reviews in db');\r\n                        DBHelper.fetchReviewsFromNetwork(callback);\r\n                    }\r\n                });\r\n            } else {\r\n                // console.log('db not found');\r\n                DBHelper.fetchReviewsFromNetwork(callback);\r\n            }\r\n        }).then(function () {}).catch(function () {\r\n            // console.log('Catch the promise error');\r\n            DBHelper.fetchReviewsFromNetwork(callback);\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Fetch a review by its ID.\r\n     */\r\n    static fetchReviewById(id, callback) {\r\n        // fetch all reviews with proper error handling.\r\n        DBHelper.fetchReviews(null, (error, reviews) => {\r\n            if (error) {\r\n                callback(error, null);\r\n            } else {\r\n                const review = reviews.find(r => r.id == id);\r\n                if (review) { // Got the review\r\n                    callback(null, review);\r\n                } else { // review does not exist in the database\r\n                    callback('Review does not exist', null);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Fetch all reviews from network.\r\n     */\r\n    static fetchReviewsFromNetwork(callback, saveToDB = true) {\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open('GET', DBHelper.DATABASE_REVIEWS_URL);\r\n        xhr.onload = () => {\r\n            if (xhr.status === 200) { // Got a success response from server!\r\n                const reviews = JSON.parse(xhr.responseText);\r\n                // console.log('Reviews lette dal server');\r\n                callback(null, reviews);\r\n                // write reviews to db\r\n                if (saveToDB) {\r\n                    DBHelper.saveReviewsToDB(reviews);\r\n                }\r\n            } else { // Oops!. Got an error from server.\r\n                const error = (`Request failed. Returned status of ${xhr.status}`);\r\n                callback(error, null);\r\n            }\r\n        };\r\n        xhr.send();\r\n    }\r\n\r\n    /*\r\n     * Save reviews to local database\r\n     */\r\n    static saveReviewsToDB(data) {\r\n        if (!(DBHelper.dbOpened)) {\r\n            return\r\n        }\r\n\r\n        let tx = DBHelper.dbPromise.transaction('reviews', 'readwrite');\r\n        let reviewsStore = tx.objectStore('reviews');\r\n        data.forEach(function (reviews) {\r\n            reviewsStore.put(reviews);\r\n        });\r\n        // console.log(\"Local reviews DB updated from Network\");\r\n        return tx.complete;\r\n    }\r\n\r\n    /**\r\n     * get all reviews.\r\n     * @restaurant_id : if specified get only the reviews of this restaurants\r\n     */\r\n    static getReviewsFromDB(restaurant_id) {\r\n        if (!DBHelper.dbPromise) return;\r\n        const tx = DBHelper.dbPromise.transaction('reviews', 'readonly');\r\n        const reviewsStore = tx.objectStore('reviews');\r\n        if (!restaurant_id) {\r\n            return reviewsStore.getAll();\r\n        } else {\r\n            let index = reviewsStore.index('restaurant');\r\n            return index.getAll(Number(restaurant_id));\r\n        }\r\n    }\r\n}","let restaurants,\r\n    neighborhoods,\r\n    cuisines\r\n// use var to define map to avoid an error with API\r\nvar map\r\nvar markers = []\r\nvar google\r\n\r\n/**\r\n * create observe to show images only when they are in viewport\r\n */\r\nlet showImage = function (entries, observer) {\r\n    entries.forEach(entry => {\r\n        if (entry.isIntersecting) {\r\n            loadPicture(entry.target);\r\n            observer.unobserve(entry.target);\r\n        }\r\n    });\r\n};\r\n\r\nconst options = {\r\n    root: null,\r\n    rootMargin: '0px',\r\n    threshold: [0]\r\n}\r\nlet observer = new IntersectionObserver(showImage, options);\r\n\r\n/**\r\n * loads the picture\r\n */\r\nfunction loadPicture(picture) {\r\n    const source_webp = picture.getElementsByTagName('source')[0]\r\n    const source_jpg = picture.getElementsByTagName('source')[1]\r\n    const img = picture.getElementsByTagName('img')[0]\r\n\r\n    const src_webp = source_webp.dataset.src;\r\n    const src_jpg = source_jpg.dataset.src;\r\n    const src = img.dataset.src;\r\n    if (!src) {\r\n        return;\r\n    }\r\n    source_webp.srcset = src_webp;\r\n    source_jpg.srcset = src_jpg;\r\n    img.src = src;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * checks to see if the service worker API is available, and if it is, the service worker at /sw.js is registered\r\n */\r\nif ('serviceWorker' in navigator) {\r\n    window.addEventListener('load', function () {\r\n        navigator.serviceWorker.register('/sw.js').then(function (registration) {\r\n            // Registration was successful\r\n            // // console.log('ServiceWorker registration successful with scope: ', registration.scope);\r\n        }, function (err) {\r\n            // registration failed :(\r\n            // // console.log('ServiceWorker registration failed: ', err);\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * Fetch neighborhoods and cuisines as soon as the page is loaded.\r\n */\r\ndocument.addEventListener('DOMContentLoaded', (event) => {\r\n    fetchNeighborhoods();\r\n    fetchCuisines();\r\n});\r\n\r\n/**\r\n * Fetch all neighborhoods and set their HTML.\r\n */\r\nconst fetchNeighborhoods = () => {\r\n    DBHelper.fetchNeighborhoods((error, neighborhoods) => {\r\n        if (error) { // Got an error\r\n            console.error(error);\r\n        } else {\r\n            self.neighborhoods = neighborhoods;\r\n            fillNeighborhoodsHTML();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Set neighborhoods HTML.\r\n */\r\nconst fillNeighborhoodsHTML = (neighborhoods = self.neighborhoods) => {\r\n    const select = document.getElementById('neighborhoods-select');\r\n    neighborhoods.forEach(neighborhood => {\r\n        const option = document.createElement('option');\r\n        option.innerHTML = neighborhood;\r\n        option.value = neighborhood;\r\n        select.append(option);\r\n    });\r\n}\r\n\r\n/**\r\n * Fetch all cuisines and set their HTML.\r\n */\r\nconst fetchCuisines = () => {\r\n    DBHelper.fetchCuisines((error, cuisines) => {\r\n        if (error) { // Got an error!\r\n            console.error(error);\r\n        } else {\r\n            self.cuisines = cuisines;\r\n            fillCuisinesHTML();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Set cuisines HTML.\r\n */\r\nconst fillCuisinesHTML = (cuisines = self.cuisines) => {\r\n    const select = document.getElementById('cuisines-select');\r\n\r\n    cuisines.forEach(cuisine => {\r\n        const option = document.createElement('option');\r\n        option.innerHTML = cuisine;\r\n        option.value = cuisine;\r\n        select.append(option);\r\n    });\r\n}\r\n\r\n/**\r\n * Update page and map for current restaurants.\r\n */\r\nconst updateRestaurants = () => {\r\n    const cSelect = document.getElementById('cuisines-select');\r\n    const nSelect = document.getElementById('neighborhoods-select');\r\n\r\n    const cIndex = cSelect.selectedIndex;\r\n    const nIndex = nSelect.selectedIndex;\r\n\r\n    const cuisine = cSelect[cIndex].value;\r\n    const neighborhood = nSelect[nIndex].value;\r\n\r\n    DBHelper.fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, (error, restaurants) => {\r\n        if (error) { // Got an error!\r\n            console.error(error);\r\n        } else {\r\n            resetRestaurants(restaurants);\r\n            fillRestaurantsHTML();\r\n        }\r\n    })\r\n}\r\n\r\n/**\r\n * Clear current restaurants, their HTML and remove their map markers.\r\n */\r\nconst resetRestaurants = (restaurants) => {\r\n    // Remove all restaurants\r\n    self.restaurants = [];\r\n    const ul = document.getElementById('restaurants-list');\r\n    ul.innerHTML = '';\r\n\r\n    // Remove all map markers\r\n    self.restaurants = restaurants;\r\n    //exit if Google Maps is disabled\r\n    if (document.getElementById('map').classList.contains('inactive')) {\r\n        return;\r\n    }\r\n    self.markers.forEach(m => m.setMap(null));\r\n    self.markers = [];\r\n}\r\n\r\n/**\r\n * Create all restaurants HTML and add them to the webpage.\r\n */\r\nconst fillRestaurantsHTML = (restaurants = self.restaurants) => {\r\n    const ul = document.getElementById('restaurants-list');\r\n    restaurants.forEach(restaurant => {\r\n        ul.append(createRestaurantHTML(restaurant));\r\n    });\r\n    if (document.getElementById('image-blurred-text').hidden) {\r\n        addMarkersToMap();\r\n    }\r\n}\r\n\r\n/**\r\n * Create restaurant HTML.\r\n */\r\nconst createRestaurantHTML = (restaurant) => {\r\n\r\n    const li = document.createElement('li');\r\n\r\n    const picture = document.createElement('picture');\r\n\r\n    const picture_source_webp = document.createElement('source');\r\n    picture_source_webp.setAttribute('type', 'image/webp');\r\n    picture.append(picture_source_webp);\r\n\r\n    const picture_source_jpg = document.createElement('source');\r\n    picture_source_jpg.setAttribute('type', 'image/jpeg');\r\n    picture.append(picture_source_jpg);\r\n\r\n    const image = document.createElement('img');\r\n    image.className = 'restaurant-img';\r\n    image.alt = DBHelper.imageDescriptionForRestaurant(restaurant);\r\n    // lazy load images only if the browser support Intersection Observer\r\n    if ('IntersectionObserver' in window) {\r\n        picture_source_webp.setAttribute('data-src', `${DBHelper.imageUrlForRestaurant(restaurant)}.webp`);\r\n        picture_source_jpg.setAttribute('data-src', `${DBHelper.imageUrlForRestaurant(restaurant)}.jpg`);\r\n        image.setAttribute('data-src', `${DBHelper.imageUrlForRestaurant(restaurant)}.jpg`);\r\n    } else {\r\n        picture_source_webp.setAttribute('srcset', `${DBHelper.imageUrlForRestaurant(restaurant)}.webp`);\r\n        picture_source_jpg.setAttribute('srcset', `${DBHelper.imageUrlForRestaurant(restaurant)}.jpg`);\r\n        image.src = `${DBHelper.imageUrlForRestaurant(restaurant)}.jpg`;\r\n    }\r\n    picture.append(image);\r\n    li.append(picture);\r\n    observer.observe(picture);\r\n\r\n    const name = document.createElement('h1');\r\n    name.innerHTML = restaurant.name + \" \";\r\n    const favorite_icon = document.createElement('i');\r\n    favorite_icon.innerHTML = 'favorite';\r\n    favorite_icon.classList.add('material-icons');\r\n    favorite_icon.classList.add('restaurant-name_favorite');\r\n    if (restaurant.is_favorite) {\r\n        if ((restaurant.is_favorite == true) || (restaurant.is_favorite == \"true\")) {\r\n            favorite_icon.classList.add('restaurant-name_isfavorite');\r\n        }\r\n    }\r\n    // will use restaurant id to set field in DB\r\n    favorite_icon.id = restaurant.id;\r\n    name.append(favorite_icon);\r\n    li.append(name);\r\n\r\n    favorite_icon.addEventListener(\"click\", onFavoriteClick);\r\n\r\n    const neighborhood = document.createElement('p');\r\n    neighborhood.innerHTML = restaurant.neighborhood;\r\n    li.append(neighborhood);\r\n\r\n    const address = document.createElement('p');\r\n    address.innerHTML = restaurant.address;\r\n    li.append(address);\r\n\r\n    const more = document.createElement('button');\r\n    more.innerHTML = 'View Details';\r\n    more.addEventListener(\"click\", function () {\r\n        window.location.href = DBHelper.urlForRestaurant(restaurant);\r\n    });\r\n    li.append(more)\r\n\r\n    return li\r\n}\r\n\r\n/**\r\n * Add markers for current restaurants to the map.\r\n */\r\nconst addMarkersToMap = (restaurants = self.restaurants) => {\r\n    restaurants.forEach(restaurant => {\r\n        // Add marker to the map\r\n        const marker = DBHelper.mapMarkerForRestaurant(restaurant, self.map);\r\n        google.maps.event.addListener(marker, 'click', () => {\r\n            window.location.href = marker.url\r\n        });\r\n        self.markers.push(marker);\r\n    });\r\n}\r\n\r\n/**\r\n * Initialize Google map, called from HTML.\r\n */\r\nwindow.initMap = () => {\r\n    let loc = {\r\n        lat: 40.722216,\r\n        lng: -73.987501\r\n    };\r\n    self.map = new google.maps.Map(document.getElementById('map'), {\r\n        zoom: 12,\r\n        center: loc,\r\n        gestureHandling: 'cooperative'\r\n    });\r\n    updateRestaurants();\r\n    document.getElementById('map').classList.remove('inactive');\r\n    document.getElementById('image-blurred').classList.remove('blur');\r\n    document.getElementById('image-blurred-text').hidden = true;\r\n}\r\n\r\nwindow.googleMapsError = () => {\r\n    // // console.log('Google Maps Error to handle');\r\n}\r\n\r\nfunction gm_authFailure() {\r\n    // // console.log('Google Maps Error to handle');\r\n}\r\n\r\nfunction showMap() {\r\n    const scrMaps = document.getElementById('GoogleMaps');\r\n    scrMaps.src = scrMaps.dataset.src;\r\n}\r\n\r\nwindow.addEventListener('load', (event) => {\r\n    DBHelper.syncRestaurants();\r\n    updateRestaurants();\r\n    document.getElementById('map-container').addEventListener(\"click\", showMap);\r\n});\r\n\r\nfunction onFavoriteClick(e) {\r\n    const favorite = e.target;\r\n    // // console.log(\"Click on favorite: \", favorite.id);\r\n    let value = \"false\"\r\n    if (!(favorite.classList.contains(\"restaurant-name_isfavorite\"))) {\r\n        value = \"true\";\r\n    };\r\n    DBHelper.updateFavorite(favorite.id, value, (error, toggle) => {\r\n        if (toggle) {\r\n            favorite.classList.toggle(\"restaurant-name_isfavorite\");\r\n        }\r\n    });\r\n}\r\n\r\n\r\nwindow.addEventListener('online', (event) => {\r\n    // // console.log(\"You are online\")\r\n    DBHelper.syncRestaurants();\r\n});\r\n\r\nwindow.addEventListener('offline', (event) => {\r\n    // // console.log(\"You are offline\")\r\n    alert(\"You are offine. All the changes will be synchronized when you return online.\");\r\n});"]}